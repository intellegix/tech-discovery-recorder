<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tech Discovery Recorder</title>
    <style>
        :root {
            --color-primary: #38bdf8;
            --color-bg: #0f172a;
            --color-surface: #1e293b;
            --color-text: #f1f5f9;
            --color-text-secondary: #cbd5e1;
            --color-success: #10b981;
            --color-danger: #ef4444;
            --color-warning: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 28px;
            margin-bottom: 8px;
            color: var(--color-primary);
        }

        .subtitle {
            color: var(--color-text-secondary);
            font-size: 14px;
        }

        .legal-banner {
            background-color: rgba(245, 158, 11, 0.1);
            border-left: 4px solid #f59e0b;
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 13px;
            color: var(--color-text-secondary);
        }

        .legal-banner strong {
            color: #f59e0b;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background-color: var(--color-surface);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: var(--color-primary);
        }

        .card-section {
            margin-bottom: 16px;
        }

        .card-section:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--color-text);
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: var(--color-text);
            font-family: inherit;
            font-size: 14px;
            margin-bottom: 8px;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--color-primary);
            background-color: rgba(255, 255, 255, 0.08);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }

        button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-bg);
        }

        .btn-primary:hover {
            background-color: #06b6d4;
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        \1
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            margin-left: 5px;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
            transform: translateY(-1px);
        }

        .pdf-export-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            color: #3b82f6;
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--color-text);
        }

        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-recording {
            background-color: rgba(239, 68, 68, 0.2);
            color: #fecaca;
        }

        .status-recording::before {
            content: '';
            width: 8px;
            height: 8px;
            background-color: #ef4444;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-ready {
            background-color: rgba(16, 185, 129, 0.2);
            color: #a7f3d0;
        }

        .status-ready::before {
            content: 'âœ“';
            color: #10b981;
        }

        .status-error {
            background-color: rgba(239, 68, 68, 0.2);
            color: #fecaca;
        }

        .status-error::before {
            content: 'âš ';
        }

        .recordings-list {
            margin-top: 20px;
        }

        .recording-item {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .recording-info {
            flex: 1;
        }

        .recording-name {
            font-weight: 500;
            color: var(--color-text);
        }

        .recording-meta {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-top: 4px;
        }

        .recording-actions {
            display: flex;
            gap: 8px;
        }

        .recording-actions button {
            flex: 0;
            padding: 6px 12px;
            font-size: 12px;
        }

        .api-config {
            background-color: rgba(59, 130, 246, 0.1);
            border-left: 4px solid var(--color-primary);
            padding: 12px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 12px;
        }

        .api-config code {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 2px;
            font-family: 'Courier New', monospace;
        }

        .consent-form {
            background-color: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .consent-form h3 {
            color: var(--color-success);
            font-size: 14px;
            margin-bottom: 12px;
        }

        .consent-text {
            font-size: 13px;
            color: var(--color-text-secondary);
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .checkbox-group label {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .architecture-section {
            background-color: var(--color-surface);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 20px;
        }

        .architecture-section h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: var(--color-primary);
        }

        .diagram {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px dashed rgba(56, 189, 248, 0.3);
            padding: 16px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            color: var(--color-primary);
            line-height: 1.6;
        }

        .stack-item {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid var(--color-primary);
        }

        .stack-item strong {
            color: var(--color-primary);
        }

        .stack-item .description {
            color: var(--color-text-secondary);
            font-size: 13px;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ™ï¸ Tech Discovery Recorder</h1>
            <p class="subtitle">Local audio recording + Claude AI transcription for compliant technical discovery</p>
        </header>

        <div class="legal-banner">
            <strong>âš–ï¸ California Compliance:</strong> This system ensures all-party consent + local processing. Start every call with: <em>"I'm recording this on my phone for technical documentation. This recording will be transcribed using my own AI processing. Does everyone consent?"</em>
        </div>

        <div class="grid">
            <!-- Recording Control Panel -->
            <div class="card">
                <h2>Recording Control</h2>

                <div class="consent-form">
                    <h3>âœ“ Pre-Recording Checklist</h3>
                    <div class="consent-text">
                        Before you record, ensure:
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="consent-verbal" />
                        <label for="consent-verbal">All participants verbally consented to recording</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="consent-documented" />
                        <label for="consent-documented">Documented consent in contract/email (recommended)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="consent-purpose" />
                        <label for="consent-purpose">Explained: <em>"Local recording, local AI processing, technical documentation only"</em></label>
                    </div>
                </div>

                <div class="card-section">
                    <label for="call-name">Call/Meeting Name</label>
                    <input type="text" id="call-name" placeholder="e.g., Client XYZ - Architecture Review" />
                </div>

                <div class="card-section">
                    <label for="participants">Participants (comma-separated)</label>
                    <textarea id="participants" rows="3" placeholder="John Doe, Jane Smith, Client Contact"></textarea>
                </div>

                <div class="card-section">
                    <label for="context">Technical Context (optional)</label>
                    <textarea id="context" rows="2" placeholder="Integration scope, systems involved, etc."></textarea>
                </div>

                <div class="card-section">
                    <div id="recording-status" class="status-indicator status-ready">
                        âœ“ Ready
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="start-recording">ğŸ”´ Start Recording</button>
                    <button class="btn-danger" id="stop-recording" disabled>â¹ï¸ Stop Recording</button>
                </div>

                <div class="api-config">
                    <strong>Backend API:</strong> Connected to <span id="api-endpoint">http://localhost:8000</span>
                    <br/>Status: <span id="api-status">Checking...</span>
                </div>
            </div>

            <!-- Processing & Transcription Panel -->
            <div class="card">
                <h2>Processing Pipeline</h2>

                <div class="card-section">
                    <label>Processing Workflow</label>
                    <div class="diagram">
User Phone Audio
        â†“
[Local Storage]
        â†“
Upload to Backend
        â†“
Claude API (whisper)
        â†“
Transcription
        â†“
Claude Processing
        â†“
Structured Notes
        â†“
[Local Vault]
                    </div>
                </div>

                <div class="card-section">
                    <label for="claude-api-key">Claude API Key (Your Backend)</label>
                    <input type="password" id="claude-api-key" placeholder="sk-ant-..." />
                </div>

                <div class="card-section">
                    <label for="processing-type">Processing Type</label>
                    <select id="processing-type">
                        <option value="full">Full Transcription + Summary + Action Items</option>
                        <option value="summary">Summary Only (faster)</option>
                        <option value="technical">Technical Spec Extraction</option>
                        <option value="custom">Custom Prompt</option>
                    </select>
                </div>

                <div class="card-section">
                    <label for="custom-prompt" style="display: none;">Custom Processing Prompt</label>
                    <textarea id="custom-prompt" style="display: none;" rows="3" placeholder="Define your custom extraction logic..."></textarea>
                </div>

                <button class="btn-primary" id="process-latest" disabled>ğŸš€ Process Last Recording</button>

                <div class="card-section" style="margin-top: 16px;">
                    <label>Processing Status</label>
                    <div id="processing-status" class="status-indicator status-ready">
                        âœ“ Idle
                    </div>
                </div>
            </div>
        </div>

        <!-- Recordings Vault -->
        <div class="card">
            <h2>Recording Vault</h2>
            <div id="recordings-list" class="recordings-list">
                <div style="color: var(--color-text-secondary); font-size: 13px;">
                    No recordings yet. Start recording above to populate this vault.
                </div>
            </div>
        </div>

        <!-- Architecture Blueprint -->
        <div class="architecture-section">
            <h2>ğŸ“ System Architecture</h2>

            <div style="margin-bottom: 20px;">
                <h3 style="color: var(--color-primary); margin-bottom: 12px; font-size: 14px;">Core Components</h3>
                
                <div class="stack-item">
                    <strong>1. Client Layer (Your Phone)</strong>
                    <div class="description">
                        âœ“ Audio recording via Web Audio API (this browser)<br/>
                        âœ“ Local IndexedDB storage (no cloud auto-upload)<br/>
                        âœ“ User interface for metadata capture (names, context)<br/>
                        âœ“ Consent tracking (checkbox confirmation)
                    </div>
                </div>

                <div class="stack-item">
                    <strong>2. Secure Backend (Your Infrastructure)</strong>
                    <div class="description">
                        âœ“ AWS Lambda / Render / Your server<br/>
                        âœ“ Receives encrypted audio files from phone<br/>
                        âœ“ Validates consent metadata + participants<br/>
                        âœ“ Calls Claude API for transcription (whisper)<br/>
                        âœ“ Returns transcript + structured notes to phone<br/>
                        âœ“ Implements retention policy (auto-delete after N days)
                    </div>
                </div>

                <div class="stack-item">
                    <strong>3. Claude Integration (LangChain)</strong>
                    <div class="description">
                        âœ“ Receive raw transcription from Whisper<br/>
                        âœ“ Process via Claude 3.5 Sonnet<br/>
                        âœ“ Extract: action items, decisions, architecture details<br/>
                        âœ“ Format as structured markdown/JSON<br/>
                        âœ“ Return to backend for logging
                    </div>
                </div>

                <div class="stack-item">
                    <strong>4. Storage & Audit (Vault)</strong>
                    <div class="description">
                        âœ“ Immutable audit log: metadata + consent + processing chain<br/>
                        âœ“ Encrypted storage of transcripts/notes<br/>
                        âœ“ Retention policy: documents deletion timeline<br/>
                        âœ“ Access controls: only authenticated user + backend<br/>
                        âœ“ No external vendor access (Anthropic's API only, no training)
                    </div>
                </div>
            </div>

            <div>
                <h3 style="color: var(--color-primary); margin-bottom: 12px; font-size: 14px;">Data Flow Diagram</h3>
                <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ YOUR PHONE (Browser)                                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 1. Start Recording                                      â”‚ â”‚
â”‚ â”‚    - Capture audio (Web Audio API)                      â”‚ â”‚
â”‚ â”‚    - Store locally (IndexedDB)                          â”‚ â”‚
â”‚ â”‚    - Track consent (checkboxes)                         â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚              â†“                                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 2. Prepare for Upload                                   â”‚ â”‚
â”‚ â”‚    - Compress audio (WebM Opus)                         â”‚ â”‚
â”‚ â”‚    - Create metadata JSON (names, context)              â”‚ â”‚
â”‚ â”‚    - Attach consent proof                               â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ HTTPS + JWT Auth (encrypted)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ YOUR BACKEND (AWS Lambda / Render / Custom)                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 3. Receive & Validate                                   â”‚ â”‚
â”‚ â”‚    - Verify JWT auth token                              â”‚ â”‚
â”‚ â”‚    - Validate consent metadata                          â”‚ â”‚
â”‚ â”‚    - Store encrypted copy (immutable log)               â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚              â†“                                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 4. Claude API Call                                      â”‚ â”‚
â”‚ â”‚    - whisper-1 transcription via Claude                 â”‚ â”‚
â”‚ â”‚    - LangChain orchestration                            â”‚ â”‚
â”‚ â”‚    - Extract action items, decisions, arch details      â”‚ â”‚
â”‚ â”‚    - Format output (markdown, JSON)                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚              â†“                                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 5. Return & Log                                         â”‚ â”‚
â”‚ â”‚    - Send transcript + structured notes to phone        â”‚ â”‚
â”‚ â”‚    - Log processing event in audit trail                â”‚ â”‚
â”‚ â”‚    - Apply retention policy (schedule deletion)         â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ HTTPS + JWT (encrypted)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ YOUR PHONE (Browser)                                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 6. Store Locally                                        â”‚ â”‚
â”‚ â”‚    - Save transcript (IndexedDB)                        â”‚ â”‚
â”‚ â”‚    - Save structured notes                              â”‚ â”‚
â”‚ â”‚    - Update audit log                                   â”‚ â”‚
â”‚ â”‚    - Display to user                                    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚              â†“                                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 7. User Actions                                         â”‚ â”‚
â”‚ â”‚    - Edit notes (add context)                           â”‚ â”‚
â”‚ â”‚    - Export (markdown, JSON)                            â”‚ â”‚
â”‚ â”‚    - Search archive                                     â”‚ â”‚
â”‚ â”‚    - Delete (with audit trail)                          â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </div>
            </div>

            <div style="margin-top: 20px;">
                <h3 style="color: var(--color-primary); margin-bottom: 12px; font-size: 14px;">Legal Compliance Architecture</h3>
                <div class="stack-item">
                    <strong>Consent Enforcement</strong>
                    <div class="description">
                        âœ“ Mandatory checkboxes before recording starts<br/>
                        âœ“ Recording timestamp + participant list immutable<br/>
                        âœ“ Backend refuses processing without valid consent proof<br/>
                        âœ“ Audit log tracks: who recorded, when, with whom, for what
                    </div>
                </div>

                <div class="stack-item" style="margin-top: 8px;">
                    <strong>Data Isolation</strong>
                    <div class="description">
                        âœ“ No auto-upload to cloud (DOWAY, Otter, etc.)<br/>
                        âœ“ Only Claude API calls are to external service (disclosed)<br/>
                        âœ“ All audio transcripts stay in your control<br/>
                        âœ“ No training on user data (Anthropic API terms honored)
                    </div>
                </div>

                <div class="stack-item" style="margin-top: 8px;">
                    <strong>Retention & Deletion</strong>
                    <div class="description">
                        âœ“ Define retention period (e.g., 90 days)<br/>
                        âœ“ Automatic purge of audio files post-retention<br/>
                        âœ“ Keep structured notes (technical value)<br/>
                        âœ“ Immutable audit trail (who deleted, when)
                    </div>
                </div>

                <div class="stack-item" style="margin-top: 8px;">
                    <strong>Business Records</strong>
                    <div class="description">
                        âœ“ Structured output = admissible technical documentation<br/>
                        âœ“ Consent + processing chain = discoverable in litigation<br/>
                        âœ“ No CCPA violations (disclosed to participants, local processing)<br/>
                        âœ“ Defensible under California law
                    </div>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <h3 style="color: var(--color-primary); margin-bottom: 12px; font-size: 14px;">Technology Stack</h3>

                <div class="stack-item">
                    <strong>Frontend (Browser)</strong>
                    <div class="description">
                        â€¢ HTML5 Web Audio API (native recording)<br/>
                        â€¢ IndexedDB (local storage)<br/>
                        â€¢ Vanilla JavaScript (no external dependencies)<br/>
                        â€¢ Responsive UI (mobile-first design)
                    </div>
                </div>

                <div class="stack-item" style="margin-top: 8px;">
                    <strong>Backend</strong>
                    <div class="description">
                        â€¢ AWS Lambda (serverless) OR Render (simple deployment)<br/>
                        â€¢ Node.js + Express (or Python)<br/>
                        â€¢ JWT authentication<br/>
                        â€¢ PostgreSQL / DynamoDB (audit log, metadata)<br/>
                        â€¢ Encrypted storage (AWS S3 with KMS)
                    </div>
                </div>

                <div class="stack-item" style="margin-top: 8px;">
                    <strong>AI Integration</strong>
                    <div class="description">
                        â€¢ Claude 3.5 Sonnet (via Anthropic API)<br/>
                        â€¢ LangChain orchestration<br/>
                        â€¢ Structured output parsing (JSON mode)<br/>
                        â€¢ Langsmith for debugging (optional)
                    </div>
                </div>

                <div class="stack-item" style="margin-top: 8px;">
                    <strong>Security & Compliance</strong>
                    <div class="description">
                        â€¢ HTTPS/TLS for all transport<br/>
                        â€¢ JWT + API key for auth<br/>
                        â€¢ Encryption at rest (S3 KMS, DB encryption)<br/>
                        â€¢ Audit logging (immutable, timestamped)<br/>
                        â€¢ Rate limiting (prevent abuse)
                    </div>
                </div>
            </div>
        </div>

        <div style="margin-top: 40px; padding: 20px; background-color: rgba(255, 255, 255, 0.05); border-radius: 8px;">
            <h3 style="color: var(--color-primary); margin-bottom: 12px;">Next Steps</h3>
            <ol style="color: var(--color-text-secondary); font-size: 13px; line-height: 1.8;">
                <li><strong>Backend Setup:</strong> Deploy a simple Node.js + Express backend to AWS Lambda or Render that accepts audio + metadata, calls Claude API, returns transcript</li>
                <li><strong>Claude Integration:</strong> Use your LangChain skills to orchestrate: Whisper transcription â†’ Claude processing â†’ structured output extraction</li>
                <li><strong>Database:</strong> Set up PostgreSQL for audit log, metadata, and processing chain tracking</li>
                <li><strong>Encryption:</strong> Implement encrypted S3 storage for audio files, set up KMS keys</li>
                <li><strong>Retention Policy:</strong> Add cron job to delete audio files after N days; keep structured notes indefinitely</li>
                <li><strong>Legal Review:</strong> Have California attorney review your consent language, retention policy, and data handling practices</li>
                <li><strong>Testing:</strong> Test with mock recordings, validate consent metadata, confirm no cloud auto-upload</li>
                <li><strong>Client Integration:</strong> Update your service agreements to reference this system and clarify no third-party vendor involvement</li>
            </ol>
        </div>
    </div>

    <script>
        // API Configuration
        const API_BASE_URL = 'http://localhost:8001/api/v1';
        let authToken = null;

        // State management
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = null;
        let recordings = [];
        let currentUserId = 'demo-user-123';

        // API Helper Functions
        async function checkAPIHealth() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`);
                const data = await response.json();
                document.getElementById('api-status').textContent =
                    data.status === 'healthy' ? 'âœ… Connected' : 'âš ï¸ Degraded';
                return data.status === 'healthy';
            } catch (error) {
                document.getElementById('api-status').textContent = 'âŒ Offline';
                console.error('API health check failed:', error);
                return false;
            }
        }

        async function apiRequest(endpoint, options = {}) {
            const url = `${API_BASE_URL}${endpoint}`;
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };

            if (authToken) {
                headers.Authorization = `Bearer ${authToken}`;
            }

            const config = {
                ...options,
                headers
            };

            const response = await fetch(url, config);

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
            }

            return response.json();
        }

        async function uploadRecording(recordingData) {
            const formData = new FormData();
            formData.append('audio_file', recordingData.audioBlob, 'recording.webm');
            formData.append('name', recordingData.name);
            formData.append('participants', recordingData.participants.join(', '));
            formData.append('context', recordingData.context || '');
            formData.append('consent_verbal', recordingData.consented.verbal);
            formData.append('consent_documented', recordingData.consented.documented);
            formData.append('consent_purpose', recordingData.consented.purpose);
            formData.append('consent_statement', 'I am recording this call for technical documentation. This recording will be transcribed using my own AI processing. Does everyone consent?');

            const response = await fetch(`${API_BASE_URL}/recordings/`, {
                method: 'POST',
                headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {},
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.message || 'Upload failed');
            }

            return response.json();
        }

        async function loadRecordings() {
            try {
                const data = await apiRequest('/recordings/');
                recordings = data.recordings || [];
                updateRecordingsList();
            } catch (error) {
                console.error('Failed to load recordings:', error);
                // Fall back to local storage if API is unavailable
                const stored = localStorage.getItem('tech_discovery_recordings');
                if (stored) {
                    recordings = JSON.parse(stored);
                    updateRecordingsList();
                }
            }
        }

        // DOM Elements
        const startBtn = document.getElementById('start-recording');
        const stopBtn = document.getElementById('stop-recording');
        const recordingStatusEl = document.getElementById('recording-status');
        const callNameInput = document.getElementById('call-name');
        const participantsInput = document.getElementById('participants');
        const contextInput = document.getElementById('context');
        const consentVerbalCheckbox = document.getElementById('consent-verbal');
        const consentDocumentedCheckbox = document.getElementById('consent-documented');
        const consentPurposeCheckbox = document.getElementById('consent-purpose');
        const recordingsListEl = document.getElementById('recordings-list');
        const processingTypeSelect = document.getElementById('processing-type');
        const customPromptInput = document.getElementById('custom-prompt');
        const processLatestBtn = document.getElementById('process-latest');
        const processingStatusEl = document.getElementById('processing-status');

        // Toggle custom prompt visibility
        processingTypeSelect.addEventListener('change', (e) => {
            customPromptInput.parentElement.style.display = e.target.value === 'custom' ? 'block' : 'none';
            customPromptInput.style.display = e.target.value === 'custom' ? 'block' : 'none';
        });

        // Start Recording
        startBtn.addEventListener('click', async () => {
            // Validate consent
            if (!consentVerbalCheckbox.checked) {
                alert('âš ï¸ You must confirm all parties consented verbally to recording.');
                return;
            }

            // Validate metadata
            if (!callNameInput.value.trim()) {
                alert('âš ï¸ Please enter a call/meeting name.');
                return;
            }

            if (!participantsInput.value.trim()) {
                alert('âš ï¸ Please list all participants.');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                recordingStartTime = new Date();

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    saveRecording(audioBlob);
                };

                mediaRecorder.start();

                // Update UI
                startBtn.disabled = true;
                stopBtn.disabled = false;
                callNameInput.disabled = true;
                participantsInput.disabled = true;
                contextInput.disabled = true;
                recordingStatusEl.className = 'status-indicator status-recording';
                recordingStatusEl.innerHTML = 'ğŸ”´ Recording in progress...';
            } catch (error) {
                alert('âŒ Microphone access denied: ' + error.message);
            }
        });

        // Stop Recording
        stopBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();

                // Stop all audio tracks
                mediaRecorder.stream.getTracks().forEach(track => track.stop());

                // Update UI
                startBtn.disabled = false;
                stopBtn.disabled = true;
                callNameInput.disabled = false;
                participantsInput.disabled = false;
                contextInput.disabled = false;
                recordingStatusEl.className = 'status-indicator status-ready';
                recordingStatusEl.innerHTML = 'âœ“ Recording saved';

                // Enable process button
                processLatestBtn.disabled = false;
            }
        });

        // Save Recording
        async function saveRecording(audioBlob) {
            const recordingData = {
                name: callNameInput.value,
                participants: participantsInput.value.split(',').map(p => p.trim()),
                context: contextInput.value,
                timestamp: recordingStartTime,
                duration: Math.round((new Date() - recordingStartTime) / 1000),
                consented: {
                    verbal: consentVerbalCheckbox.checked,
                    documented: consentDocumentedCheckbox.checked,
                    purpose: consentPurposeCheckbox.checked,
                },
                audioBlob: audioBlob,
                transcript: null,
                structured_notes: null,
                processing_status: 'pending',
            };

            try {
                recordingStatusEl.className = 'status-indicator status-recording';
                recordingStatusEl.innerHTML = 'ğŸ“¤ Uploading...';

                // Upload to backend
                const uploadedRecording = await uploadRecording(recordingData);

                // Add to local array for immediate UI update
                recordings.push({
                    ...recordingData,
                    id: uploadedRecording.id,
                    processing_status: uploadedRecording.processing_status,
                    created_at: uploadedRecording.created_at
                });

                // Store backup in localStorage
                localStorage.setItem('tech_discovery_recordings', JSON.stringify(recordings));

                updateRecordingsList();
                resetForm();

                // Enable process button
                processLatestBtn.disabled = false;

                recordingStatusEl.className = 'status-indicator status-ready';
                recordingStatusEl.innerHTML = 'âœ… Uploaded successfully';

            } catch (error) {
                console.error('Upload failed:', error);

                // Fall back to local storage
                recordingData.id = Date.now();
                recordingData.uploadError = error.message;
                recordings.push(recordingData);
                localStorage.setItem('tech_discovery_recordings', JSON.stringify(recordings));

                updateRecordingsList();
                resetForm();

                recordingStatusEl.className = 'status-indicator status-error';
                recordingStatusEl.innerHTML = 'âš ï¸ Upload failed, saved locally';

                alert(`Upload failed: ${error.message}\nRecording saved locally. Will retry when backend is available.`);
            }
        }

        // Update Recordings List UI
        function updateRecordingsList() {
            if (recordings.length === 0) {
                recordingsListEl.innerHTML = '<div style="color: var(--color-text-secondary); font-size: 13px;">No recordings yet. Start recording above to populate this vault.</div>';
                return;
            }

            recordingsListEl.innerHTML = recordings.map((rec, idx) => {
                // Handle both old format (duration) and new format (created_at)
                let timestamp, duration = '';

                if (rec.timestamp) {
                    timestamp = new Date(rec.timestamp).toLocaleString();
                    duration = Math.floor(rec.duration / 60) + 'm ' + (rec.duration % 60) + 's';
                } else if (rec.created_at) {
                    timestamp = new Date(rec.created_at).toLocaleString();
                }

                // Determine status
                let status, statusClass = '';
                switch (rec.processing_status) {
                    case 'completed':
                        status = 'âœ… Processed';
                        statusClass = 'status-ready';
                        break;
                    case 'processing':
                        status = 'ğŸ¤– Processing...';
                        statusClass = 'status-recording';
                        break;
                    case 'failed':
                        status = 'âŒ Failed';
                        statusClass = 'status-error';
                        break;
                    case 'pending':
                    default:
                        status = 'â³ Pending';
                        statusClass = 'status-ready';
                        break;
                }

                // Handle participants (could be array or string)
                const participants = Array.isArray(rec.participants)
                    ? rec.participants.join(', ')
                    : rec.participants || 'Unknown';

                const uploadError = rec.uploadError ? `<br/><span style="color: var(--color-warning);">âš ï¸ ${rec.uploadError}</span>` : '';

                return `
                    <div class="recording-item">
                        <div class="recording-info">
                            <div class="recording-name">${rec.name}</div>
                            <div class="recording-meta">
                                ${timestamp} ${duration ? 'â€¢ ' + duration : ''} â€¢ ${participants}<br/>
                                <span class="status-indicator ${statusClass}">${status}</span>${uploadError}
                            </div>
                        </div>
                        <div class="recording-actions">
                            <button class="btn-secondary" onclick="exportRecording('${rec.id}')">ğŸ“¥ Export JSON</button>
                            <button class="btn-primary" onclick="exportPDF('${rec.id}')">ğŸ“„ Export PDF</button>
                            <button class="btn-danger" onclick="deleteRecording('${rec.id}')">ğŸ—‘ï¸ Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Export Recording
        window.exportRecording = async (id) => {
            const rec = recordings.find(r => r.id == id);
            if (!rec) return;

            try {
                let exportData;

                // If recording is from backend, get full data
                if (rec.created_at && !rec.uploadError) {
                    const fullRecording = await apiRequest(`/recordings/${id}`);
                    exportData = {
                        recording_metadata: {
                            id: fullRecording.id,
                            name: fullRecording.name,
                            participants: fullRecording.participants,
                            context: fullRecording.context,
                            created_at: fullRecording.created_at,
                            processing_status: fullRecording.processing_status,
                        },
                        consent_proof: fullRecording.consent_proof,
                        transcript: fullRecording.transcript,
                        structured_notes: fullRecording.structured_notes,
                        retention_expires_at: fullRecording.retention_expires_at,
                        export_timestamp: new Date().toISOString(),
                        compliance_note: "This recording was processed with all-party consent in compliance with California Penal Code Â§ 632"
                    };
                } else {
                    // Local recording fallback
                    exportData = {
                        recording_metadata: {
                            id: rec.id,
                            name: rec.name,
                            participants: rec.participants,
                            context: rec.context,
                            timestamp: rec.timestamp,
                            duration: rec.duration,
                            processing_status: rec.processing_status || 'local'
                        },
                        consent_proof: rec.consented,
                        transcript: rec.transcript,
                        structured_notes: rec.structured_notes || rec.notes,
                        upload_error: rec.uploadError || null,
                        export_timestamp: new Date().toISOString()
                    };
                }

                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `tech-discovery-${rec.name.replace(/[^a-zA-Z0-9]/g, '-')}-${id}.json`;
                a.click();
                URL.revokeObjectURL(url);

                // Log export action
                console.log(`Exported recording: ${rec.name} (ID: ${id})`);

            } catch (error) {
                console.error('Export failed:', error);
                alert(`Export failed: ${error.message}`);
            }
        };

        // Delete Recording
        window.deleteRecording = async (id) => {
            const rec = recordings.find(r => r.id == id);
            if (!rec) return;

            const confirmMsg = `Delete recording "${rec.name}"?\n\nThis action cannot be undone and will:\nâ€¢ Remove the recording from the system\nâ€¢ Delete associated audio files\nâ€¢ Maintain audit trail for compliance`;

            if (!confirm(confirmMsg)) return;

            try {
                // If recording is on backend, delete via API
                if (rec.created_at && !rec.uploadError) {
                    await apiRequest(`/recordings/${id}`, { method: 'DELETE' });
                }

                // Remove from local array
                recordings = recordings.filter(r => r.id != id);
                localStorage.setItem('tech_discovery_recordings', JSON.stringify(recordings));
                updateRecordingsList();

                console.log(`Deleted recording: ${rec.name} (ID: ${id})`);

            } catch (error) {
                console.error('Delete failed:', error);
                alert(`Delete failed: ${error.message}`);
            }
        };

        // Process Latest Recording
        processLatestBtn.addEventListener('click', async () => {
            if (recordings.length === 0) {
                alert('No recordings to process.');
                return;
            }

            const latestRec = recordings[recordings.length - 1];

            if (latestRec.processing_status === 'completed') {
                alert('Recording has already been processed. Export to view results.');
                return;
            }

            if (latestRec.processing_status === 'processing') {
                alert('Recording is already being processed. Please wait...');
                return;
            }

            processingStatusEl.className = 'status-indicator status-recording';
            processingStatusEl.innerHTML = 'â³ Starting processing...';
            processLatestBtn.disabled = true;

            try {
                // Get processing type
                const processingType = document.getElementById('processing-type').value;
                const customPrompt = document.getElementById('custom-prompt').value;

                // Start processing via API
                const processingData = await apiRequest(`/recordings/${latestRec.id}/process`, {
                    method: 'POST',
                    body: JSON.stringify({
                        processing_type: processingType,
                        custom_prompt: customPrompt || null
                    })
                });

                // Update local status
                latestRec.processing_status = 'processing';
                processingStatusEl.innerHTML = 'ğŸ¤– AI processing in progress...';

                // Poll for completion
                pollProcessingStatus(latestRec.id);

            } catch (error) {
                console.error('Processing failed:', error);
                processingStatusEl.className = 'status-indicator status-error';
                processingStatusEl.innerHTML = 'âš  Processing failed';
                alert(`âŒ Processing error: ${error.message}`);
                processLatestBtn.disabled = false;
            }
        });

        // Poll processing status
        async function pollProcessingStatus(recordingId) {
            try {
                const statusData = await apiRequest(`/recordings/${recordingId}/status`);
                const recording = recordings.find(r => r.id === recordingId);

                if (recording) {
                    recording.processing_status = statusData.status;
                }

                switch (statusData.status) {
                    case 'processing':
                        processingStatusEl.className = 'status-indicator status-recording';
                        processingStatusEl.innerHTML = 'ğŸ¤– AI processing...';
                        // Continue polling
                        setTimeout(() => pollProcessingStatus(recordingId), 3000);
                        break;

                    case 'completed':
                        // Get updated recording data
                        const updatedRecording = await apiRequest(`/recordings/${recordingId}`);
                        const recordingIndex = recordings.findIndex(r => r.id === recordingId);

                        if (recordingIndex >= 0) {
                            recordings[recordingIndex] = {
                                ...recordings[recordingIndex],
                                ...updatedRecording,
                                processing_status: 'completed'
                            };
                        }

                        processingStatusEl.className = 'status-indicator status-ready';
                        processingStatusEl.innerHTML = 'âœ… Processing completed';
                        updateRecordingsList();
                        processLatestBtn.disabled = false;

                        alert('âœ“ Recording processed successfully! Export to view transcript and structured notes.');
                        break;

                    case 'failed':
                        processingStatusEl.className = 'status-indicator status-error';
                        processingStatusEl.innerHTML = 'âŒ Processing failed';
                        processLatestBtn.disabled = false;

                        const errorMsg = statusData.error || 'Unknown processing error';
                        alert(`âŒ Processing failed: ${errorMsg}`);
                        break;
                }
            } catch (error) {
                console.error('Status polling failed:', error);
                processingStatusEl.className = 'status-indicator status-error';
                processingStatusEl.innerHTML = 'âš  Status check failed';
                processLatestBtn.disabled = false;
            }
        }

        // Reset Form
        function resetForm() {
            callNameInput.value = '';
            participantsInput.value = '';
            contextInput.value = '';
            recordingStatusEl.className = 'status-indicator status-ready';
            recordingStatusEl.innerHTML = 'âœ“ Ready';
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ğŸ™ï¸ Tech Discovery Recorder - Production Version');
            console.log('âœ… Full backend integration with Claude AI processing');

            // Check API health
            const isAPIHealthy = await checkAPIHealth();

            if (isAPIHealthy) {
                console.log('âœ… Backend API connected');
                // Load recordings from backend
                await loadRecordings();
            } else {
                console.log('âš ï¸ Backend API not available - operating in offline mode');
                // Load from local storage as fallback
                const stored = localStorage.getItem('tech_discovery_recordings');
                if (stored) {
                    recordings = JSON.parse(stored);
                    updateRecordingsList();
                }
            }

            // Set API endpoint in UI
            document.getElementById('api-endpoint').textContent = API_BASE_URL.replace('/api/v1', '');

            console.log(`ğŸ“Š Loaded ${recordings.length} recordings`);
        });
    </script>
</body>
</html>
